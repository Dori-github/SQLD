# 4. SQL 최적화 기본 원리
## 옵티마이저와 실행계획
### 1. 옵티마이저
옵티마이저 : 사용자가 질의한 SQL문에 대해 최적의 실행 방법을 결정하는 역할.
실행 계획 : 사용자 질의 SQL문에 대한 최적의 실행 방법 .  
![sql가이드](http://www.dbguide.net/publishing/img/knowledge/SQL_239.jpg)  
대부분의 관계형 데이터베이스는 비용기반 옵티마이저를 제공. 
#### [가. 규칙기반 옵티마이저]
규칙기반 옵티마이저 : 우선순위가 높은 규칙이 적은 일량으로 해당작업을 수행하는 방법.  순위의 숫자가 낮을 수록 높은 우선순위.
![sql가이드](http://www.dbguide.net/publishing/img/knowledge/SQL_240.jpg)  
#### 규칙기반 옵티마이저 규칙 
1. Single row by rowid : ROWID 를 통해서 테이블에서 하나의 행을 엑세스 하는 방식. 행이 포함된 데이터 정보를 가지고 있어서, 다른 정보를 참지 않고도 바로 원하는 행을 엑세스 가능. 
2. Single row by unique or primary key : 유일 인덱스를 통해서 하나의 행을 엑세스 하는 방식. 
3. Composite index : 복합 인덱스에 동등('=') 조건으로 검색하는 경우. ex)WHERE A=10 AND B=1 형태
4. Single column index : 단일 컬럼 인덱스에 '=' 조건으로 검색하는 경우. ex)A=10
5. Bounded range search on indexed columns : 인덱스가 생성 된 칼럼에 양쪽 범위를 한정하는 형태로 검색하는 방식 ex) BETWEEN, LIKE - A BETWEEN '10'AND'20'또는 A LIKE '1%' 
6. Unbounded range search on indexed columns : 인덱스가 생성되어있는 칼럼에 한쪽 범위만 한정하는 형태로 검색하는 방식.ex) >,>=,<= - A>'10' 또는 A<'20'
7. Full table scan : 전체 테이블을 액세스하면서 조건절에 주어진 조건을 만족하는 행 만을 결과로 추출.

#### 규칙 기반 옵티마이저 특징 
- 규칙 기반 옵티마이저는 인덱스를 이용한 엑세스 방식이 전체 테이블 엑세스 방식 보다 우선순위가 높음. 
- 조인 순서 결정시 조인 칼럼 인덱스의 존재 유무가 중요한 판단 기준. 
- 테이블 양쪽 모두 존재 시 인덱스가 없는 테이블을 선행 테이블로 선택하여 조인 수행.
-  조인 칼럼 모두 인덱스 존재 하지 않으면 FROM 절 뒤에 나열된 테이블을 선행 테이블로 선택. 
- 조인 테이블 우선 순위가 동일 하다면 FROM절에 나열된 테이블 역순으로 테선행 테이블을 선택. 
- 양쪽 조인 칼럼에 모두 인덱스가 없는 경우에는 Sort Merge Join을 사용하고 둘 중하나라도 조인 칼럼에 인덱스가 존재한다면 일.반적으로 NL Join을 사용
#### 규칙 기반 옵티마이저 최적화 과정
```
SELECT ENAME FROM EMP WHERE JOB = 'SALESMAN' AND SAL BETWEEN 3000 AND 6000 INDEX --------------------------------- EMP_JOB : JOB EMP_SAL : SAL PK_EMP : EMPNO (UNIQUE)
```
#### 규칙기반 옵티마이저 실행 계획
```
Execution Plan ------------------------------------------------------------ SELECT STATEMENT Optimizer=CHOOSE TABLE ACCESS (BY INDEX ROWID) OF 'EMP' INDEX (RANGE SCAN) OF 'EMP_JOB' (NON-UNIQUE)
```
#### [나. 비용기반 옵티마이저]
비용기반 옵티마이저 : SQL 문을 처리하는데 필요한 비용이 가장 적은 실행 계획을 선택하는 방식. 규칙기반 옵티마이저 단점 보완.   
![sql가이드](http://www.dbguide.net/publishing/img/knowledge/SQL_241.jpg)
#### 비용 기반 옵티마이저 구성-질의 변환기, 대안 계획 생성가, 비용 예측기 등
1. 질의 변환기 : 사용자가 작성한 SQL 문을 처리하기에 보다 용이한 형태로 변환하는 모듈
2. 대안 계획 생성기 : 동일한 결과를 생성하는 다양한 대안 계획를 생성하는 모듈
3. 대안 계획 : 연산 적용 순서 변경, 연산 방법 변경, 조인 순서 변경 등을 통해 생성. 동일 결과를 생성하는 가능한 모든 대안 계획를 생성하여 보다 나은 최적화 수행 가능. 대안 계획 생성이 너무 많아지면 최적화 수행 시간이 오래걸림. 
4. 비용 예측기 : 대안 계획 생성기에 의해서 생성된 대안 계획의 비용을 예측하는 모듈. 
### 2. 실행계획
실행계획 : SQL 요구 사항을 처리하기 위한 절차와 방법을 의미. 옵티마이저는 최적의 실행계획을 생성해줌. 실행 계획 구성요소는 조인순서, 조인 기법, 액세스 기법, 최적화 정보, 연산 등이 있다.
![sql가이드](http://www.dbguide.net/publishing/img/knowledge/SQL_242.jpg)  
조인순서 : 조인 작업 수행시 참조하는 테이블 순서. 조인 순서는 n! 만큼 존재.   
ex) A,B테이블 두개 존재 시 조인 작업시 A를 읽고 B를 읽는다면 순서는 A->B  
- [그림 Ⅱ-3-4]에서 조인 순서는 EMP → DEPT.  

조인 기법 : 두개 테이블 조인 시 사용 할 수 있는 방법. ex) NL join  , Hash Join, Sort Merge Join 등  
- [그림 Ⅱ-3-4]에서 조인 기법은 NL Join을 사용.  

액세스 기법 : 하나의 테이블을 액세스 할 때 사용 할 수 있는 방법. 여기에는 인덱스를 이용하여 테이블을 액세스 하는 인덱스 스캔, 테이블 전체를 모두 읽으면서 조건을 만족하는 행을 찾는 전체 테이블 캔이 존재.  
- [그림 Ⅱ-3-4]에서 액세스 기법은 인덱스 스캔을 사용.  

실행계획 :  비용 사항이 표시된다는 것은 비용 기반 최적화 방식으로 실행 계획을 생성했다는 것을 의미.     
최적화 정보에는 Cost, Card, Bytes.     
Cost 는 상대적인 비용 정보, Card 는 Cardinality 의 약자로서 주어진 조건을 만족한 결과 집합, 조인 조건을 만족한 결과 집합 건수를 의미. Bytes 는 결과 집합 차지하는 메모리 양을 바이트로 표시 한 것. (비용 정보 : 통계정보를 바탕으로 옵티마이저가 계산한 예상치 , 표시x: 규칙기반 최적화 방식으로 실행계획 생성.)    
- [그림 Ⅱ-3-4] 실행계획의 예에서는 비용 정보가 표시되어 있으므로 비용기반 최적화 방식으로 생성된 실행계획.  

연산 : 여러가지 조작을 통해서 원하는 결과를 얻어내는 일련의 작업. 연산에는 조인기법, 액세스 기법, 필터,정렬 등 다양한 종류 존재.   

### 3. SQL 처리 흐름도
SQL 처리 흐름도 : SQL 의 내부적인 처리 절차를 시각적으로 표현한 도표. 실행계획을 시각화 한 것.   
![sql가이드](http://www.dbguide.net/publishing/img/knowledge/SQL_243.jpg)  
- TABLE 1을 outer Table 또는 Driving table 이라 하고, TAB2를 Inner Table 혹은 Look up table 이라고 함.
- 조인순서 TAB1->TAB2
- TAB1 는 풀스캔 TB2는 인덱스 스캔
- 조인방법 : NL Join
- TAB1에 대한 액세스는 SCAN, TAB2는 랜덤 액세스
## 인덱스 기본 
### 1. 인덱스 특징과 종류
인덱스 : 원하는 데이터를 쉽게 찾을 수 있도록 돕는 책의 찾아보기와 유사한 개념. 테이블을 기반으로 선택할 수 있도록 생성할 수 있는 구조. 여러개 생성 가능. 검색 성능 최적화가 목적.  
#### [가. 트리 기반 인덱스]
![sql가이드](http://www.dbguide.net/publishing/img/knowledge/SQL_244.jpg)  
B-트리 인덱스는 '='로 검색하는 일치 검색과, 범위 검색에 모두 적합한 구조. 
#### B-트리 인덱스 구성 
그림과 같이 B-트리인덱스는 브랜치 블록, 리프 블록으로 구성. 
- 루트 블록 : 브랜치 블록 중에서 가장 위에있는 블록
- 브랜치 블록 : 분기를 목적으로 하는 블록. 다음 단계의 블록을 가리키는 포인터를 가짐.
- 리프 블록 : 가장 아래 단계에 존재. 인덱스를 구성하는 칼럼 데이터와 해당 데이터를 가지는 행의 위치를 가리키는 레코드식별자로 구성됨. 양방향 링크를 가짐. 이것을 통해 오름차순, 내림차순 쉽게 검색 가능.
#### 인덱스에서 원하는 값을 찾는 과정
1. 브랜치 블록의 가장 왼쪽 값이 찾고자 하는 값보다 작거나 같으면 왼쪽 포인터로 이동
2. 찾고자 하는 값이 브랜치 블록 값 사이에 존재 시 가운데 포인터로 이동
3. 오른쪽에 있는 값보다 크면 오른쪽 포인터로 이동.

이 과정을 리프 블록을 찾을 때 까지 반복함.  
![sql가이드](http://www.dbguide.net/publishing/img/knowledge/SQL_245.jpg)    
ex) 그림에서 37를 찾고자 한다면 루트 블록에서 50 보다 작으므로 왼쪽으로 이동. 37은 왼쪽 브랜치 블록의 11과 40의 사이 값이므로 가운데 포인터로 이동. 이동한 결과 해당 블록이 리프 블록이므로 37이 블록내 존재하는지 검색. 존재하면 검색하고자 하는 값을 찾은것. 



